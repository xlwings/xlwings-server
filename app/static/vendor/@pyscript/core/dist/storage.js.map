{"version":3,"file":"storage.js","sources":["../node_modules/sabayon/src/shared.js","../node_modules/@webreflection/idb-map/index.js","../node_modules/@webreflection/idb-map/sync.js","../node_modules/flatted/esm/index.js","../src/storage.js"],"sourcesContent":["// (c) Andrea Giammarchi - MIT\n\nconst ACTION_INIT = 0;\nconst ACTION_NOTIFY = 1;\nconst ACTION_WAIT = 2;\nconst ACTION_SW = 3;\n\nconst { ArrayBuffer, Atomics: $Atomics, Promise } = globalThis;\nconst { isArray } = Array;\nconst { create, getPrototypeOf, values } = Object;\n\nconst TypedArray = getPrototypeOf(Int32Array);\nconst Atomics = create($Atomics);\n\nconst dispatch = ({ currentTarget, type, origin, lastEventId, source, ports }, data) =>\n  currentTarget.dispatchEvent(new MessageEvent(type, { data, origin, lastEventId, source, ports }));\n\nconst withResolvers = () => Promise.withResolvers();\n\nlet id = 0;\nconst views = new Map;\nconst extend = (Class, SharedArrayBuffer) => class extends Class {\n  constructor(value, ...rest) {\n    super(value, ...rest);\n    if (value instanceof SharedArrayBuffer)\n      views.set(this, [id++, 0, withResolvers()]);\n  }\n};\n\nconst ignoreList = new WeakSet;\n\n/**\n * @template {T}\n * @callback PassThrough\n * @param {T} value\n * @returns {T}\n */\n\n/** @type {PassThrough} */\nconst ignoreDirect = value => value;\n\n/** @type {PassThrough} */\nconst ignorePatch = value => {\n  ignoreList.add(value);\n  return value;\n};\n\nconst isChannel = (event, channel) => {\n  const { data } = event;\n  const yes = isArray(data) && (\n    data.at(0) === channel ||\n    (data.at(1) === ACTION_INIT && !channel)\n  );\n  if (yes) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n  return yes;\n};\n\nconst isObject = value => (\n  value !== null &&\n  typeof value === 'object' &&\n  !ignoreList.has(value)\n);\n\nconst transferred = new WeakMap;\nconst transferViews = (data, transfer, visited) => {\n  if (views.has(data))\n    transfer.set(data, views.get(data)[0]);\n  else if (!(data instanceof TypedArray || data instanceof ArrayBuffer)) {\n    for (const value of values(data)) {\n      if (isObject(value) && !visited.has(value)) {\n        visited.add(value);\n        transferViews(value, transfer, visited);\n      }\n    }\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync#browser_compatibility\nconst waitAsyncPatch = (...args) => ({\n  value: new Promise(resolve => {\n    // encodeURIComponent('onmessage=e=>postMessage(!Atomics.wait(...e.data))')\n    let w = new Worker('data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))');\n    w.onmessage = () => resolve('ok');\n    w.postMessage(args);\n  })\n});\n\nconst waitAsyncPoly = (view, index) => {\n  const value = views.get(view), [id, _, { promise }] = value;\n  value[1] = index;\n  return [id, promise];\n};\n\nconst actionNotify = (_view, _id, _index) => {\n  for (const [view, [id, index, { resolve }]] of views) {\n    if (_id === id && _index === index) {\n      for (let i = 0; i < _view.length; i++) view[i] = _view[i];\n      views.delete(view);\n      resolve('ok');\n      break;\n    }\n  }\n};\n\nconst actionWait = (event, transfer, data) => {\n  for (const [view, id] of transfer)\n    transferred.set(view, [id, event.currentTarget]);\n  dispatch(event, data);\n};\n\nconst postData = (CHANNEL, data) => {\n  const transfer = new Map;\n  if (isObject(data)) transferViews(data, transfer, new Set);\n  return transfer.size ? [CHANNEL, ACTION_WAIT, transfer, data] : data;\n};\n\nconst getData = view => transferred.get(view);\n\nexport {\n  ACTION_INIT, ACTION_NOTIFY, ACTION_WAIT, ACTION_SW,\n\n  ArrayBuffer, Atomics, TypedArray,\n\n  actionNotify, actionWait,\n  getData, postData,\n  ignoreDirect, ignorePatch,\n  waitAsyncPatch, waitAsyncPoly,\n\n  dispatch,\n  extend,\n  isChannel,\n  views,\n  withResolvers,\n};\n","const { assign } = Object;\n\nconst STORAGE = 'entries';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\n/**\n * @typedef {Object} IDBMapOptions\n * @prop {'strict' | 'relaxed' | 'default'} [durability]\n * @prop {string} [prefix]\n */\n\n/** @typedef {[IDBValidKey, unknown]} IDBMapEntry */\n\n/** @type {IDBMapOptions} */\nconst defaultOptions = { durability: 'default', prefix: 'IDBMap' };\n\n/**\n * @template T\n * @param {{ target: IDBRequest<T> }} event\n * @returns {T}\n */\nconst result = ({ target: { result } }) => result;\n\nexport default class IDBMap extends EventTarget {\n  // Privates\n  /** @type {Promise<IDBDatabase>} */ #db;\n  /** @type {IDBMapOptions} */ #options;\n  /** @type {string} */ #prefix;\n\n  /**\n   * @template T\n   * @param {(store: IDBObjectStore) => IDBRequest<T>} what\n   * @param {'readonly' | 'readwrite'} how\n   * @returns {Promise<T>}\n   */\n  async #transaction(what, how) {\n    const db = await this.#db;\n    const t = db.transaction(STORAGE, how, this.#options);\n    return new Promise((onsuccess, onerror) => assign(\n      what(t.objectStore(STORAGE)),\n      {\n        onsuccess,\n        onerror,\n      }\n    ));\n  }\n\n  /**\n   * @param {string} name\n   * @param {IDBMapOptions} options\n   */\n  constructor(\n    name,\n    {\n      durability = defaultOptions.durability,\n      prefix = defaultOptions.prefix,\n    } = defaultOptions\n  ) {\n    super();\n    this.#prefix = prefix;\n    this.#options = { durability };\n    this.#db = new Promise((resolve, reject) => {\n      assign(\n        indexedDB.open(`${this.#prefix}/${name}`),\n        {\n          onupgradeneeded({ target: { result, transaction } }) {\n            if (!result.objectStoreNames.length)\n              result.createObjectStore(STORAGE);\n            transaction.oncomplete = () => resolve(result);\n          },\n          onsuccess(event) {\n            resolve(result(event));\n          },\n          onerror(event) {\n            reject(event);\n            this.dispatchEvent(event);\n          },\n        },\n      );\n    }).then(result => {\n      const boundDispatch = this.dispatchEvent.bind(this);\n      for (const key in result) {\n        if (key.startsWith('on'))\n          result[key] = boundDispatch;\n      }\n      return result;\n    });\n  }\n\n  // EventTarget Forwards\n  /**\n   * @param {Event} event\n   * @returns \n   */\n  dispatchEvent(event) {\n    const { type, message, isTrusted } = event;\n    return super.dispatchEvent(\n      // avoid re-dispatching of the same event\n      isTrusted ?\n        assign(new Event(type), { message }) :\n        event\n    );\n  }\n\n  // IDBDatabase Forwards\n  async close() {\n    (await this.#db).close();\n  }\n\n  // Map async API\n  get size() {\n    return this.#transaction(\n      store => store.count(),\n      READONLY,\n    ).then(result);\n  }\n\n  async clear() {\n    await this.#transaction(\n      store => store.clear(),\n      READWRITE,\n    );\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   */\n  async delete(key) {\n    await this.#transaction(\n      store => store.delete(key),\n      READWRITE,\n    );\n  }\n\n  /**\n   * @returns {Promise<IDBMapEntry[]>}\n   */\n  async entries() {\n    const keys = await this.keys();\n    return Promise.all(keys.map(key => this.get(key).then(value => [key, value])));\n  }\n\n  /**\n   * @param {(unknown, IDBValidKey, IDBMap) => void} callback\n   * @param {unknown} [context]\n   */\n  async forEach(callback, context = this) {\n    for (const [key, value] of await this.entries())\n      await callback.call(context, value, key, this);\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   * @returns {Promise<unknown | undefined>}\n   */\n  async get(key) {\n    const value = await this.#transaction(\n      store => store.get(key),\n      READONLY,\n    ).then(result);\n    return value;\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   */\n  async has(key) {\n    const k = await this.#transaction(\n      store => store.getKey(key),\n      READONLY,\n    ).then(result);\n    return k !== void 0;\n  }\n\n  async keys() {\n    const keys = await this.#transaction(\n      store => store.getAllKeys(),\n      READONLY,\n    ).then(result);\n    return keys;\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   * @param {unknown} value\n   */\n  async set(key, value) {\n    await this.#transaction(\n      store => store.put(value, key),\n      READWRITE,\n    );\n    return this;\n  }\n\n  async values() {\n    const keys = await this.keys();\n    return Promise.all(keys.map(key => this.get(key)));\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.#prefix;\n  }\n}\n","import IDBMap from './index.js';\n\nexport default class IDBMapSync extends Map {\n  #map;\n  #queue;\n  constructor(...args) {\n    super();\n    this.#map = new IDBMap(...args);\n    this.#queue = this.#map.entries().then(entries => {\n      for (const [key, value] of entries)\n        super.set(key, value);\n    });\n  }\n  async close() {\n    await this.#queue;\n    await this.#map.close();\n  }\n  async sync() {\n    await this.#queue;\n  }\n  clear() {\n    this.#queue = this.#queue.then(() => this.#map.clear());\n    return super.clear();\n  }\n  delete(key) {\n    this.#queue = this.#queue.then(() => this.#map.delete(key));\n    return super.delete(key);\n  }\n  set(key, value) {\n    this.#queue = this.#queue.then(() => this.#map.set(key, value));\n    return super.set(key, value);\n  }\n}\n","/// <reference types=\"../types/index.d.ts\" />\n\n// (c) 2020-present Andrea Giammarchi\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst {keys} = Object;\n\nconst Primitive = String;   // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => (\n  value instanceof Primitive ? Primitive(value) : value\n);\n\nconst Primitives = (_, value) => (\n  typeof value === primitive ? new Primitive(value) : value\n);\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({k, a: [input, parsed, tmp, $]});\n      }\n      else\n        output[k] = $.call(output, k, tmp);\n    }\n    else if (output[k] !== ignore)\n      output[k] = $.call(output, k, value);\n  }\n  for (let {length} = lazy, i = 0; i < length; i++) {\n    const {k, a} = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\n/**\n * Converts a specialized flatted string into a JS value.\n * @param {string} text\n * @param {(this: any, key: string, value: any) => any} [reviver]\n * @returns {any}\n */\nexport const parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ?\n              revive(input, new Set, value, $) :\n              value;\n  return $.call({'': tmp}, '', tmp);\n};\n\n/**\n * Converts a JS value into a specialized flatted string.\n * @param {any} value\n * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\n * @param {string | number | undefined} [space]\n * @returns {string}\n */\nexport const stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ?\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\n            (replacer || noop);\n  const known = new Map;\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({'': value}, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\n\n/**\n * Converts a generic value into a JSON serializable object without losing recursion.\n * @param {any} value\n * @returns {any}\n */\nexport const toJSON = value => $parse(stringify(value));\n\n/**\n * Converts a previously serialized object with recursion into a recursive one.\n * @param {any} value\n * @returns {any}\n */\nexport const fromJSON = value => parse($stringify(value));\n","import { ArrayBuffer, TypedArray } from \"sabayon/shared\";\nimport IDBMapSync from \"@webreflection/idb-map/sync\";\nimport { parse, stringify } from \"flatted\";\n\nconst to_idb = (value) => {\n    if (value == null) return stringify([\"null\", 0]);\n    /* eslint-disable no-fallthrough */\n    switch (typeof value) {\n        case \"object\": {\n            if (value instanceof TypedArray)\n                return stringify([\"memoryview\", [...value]]);\n            if (value instanceof ArrayBuffer)\n                return stringify([\"bytearray\", [...new Uint8Array(value)]]);\n        }\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return stringify([\"generic\", value]);\n        default:\n            throw new TypeError(`Unexpected value: ${String(value)}`);\n    }\n};\n\nconst from_idb = (value) => {\n    const [kind, result] = parse(value);\n    if (kind === \"null\") return null;\n    if (kind === \"generic\") return result;\n    if (kind === \"bytearray\") return new Uint8Array(value).buffer;\n    if (kind === \"memoryview\") return new Uint8Array(value);\n    return value;\n};\n\n// this export simulate pyscript.storage exposed in the Python world\nexport const storage = async (name) => {\n    if (!name) throw new SyntaxError(\"The storage name must be defined\");\n\n    const store = new IDBMapSync(`@pyscript/${name}`);\n    const map = new Map();\n    await store.sync();\n    for (const [k, v] of store.entries()) map.set(k, from_idb(v));\n\n    const clear = () => {\n        map.clear();\n        store.clear();\n    };\n\n    const sync = async () => {\n        await store.sync();\n    };\n\n    return new Proxy(map, {\n        ownKeys: (map) => [...map.keys()],\n        has: (map, name) => map.has(name),\n        get: (map, name) => {\n            if (name === \"clear\") return clear;\n            if (name === \"sync\") return sync;\n            return map.get(name);\n        },\n        set: (map, name, value) => {\n            map.set(name, value);\n            store.set(name, to_idb(value));\n            return true;\n        },\n        deleteProperty: (map, name) => {\n            if (map.has(name)) {\n                map.delete(name);\n                store.delete(name);\n            }\n            return true;\n        },\n    });\n};\n"],"names":["ArrayBuffer","Atomics","$Atomics","Promise","globalThis","create","getPrototypeOf","values","Object","TypedArray","Int32Array","assign","STORAGE","READONLY","READWRITE","defaultOptions","durability","prefix","result","target","IDBMap","EventTarget","db","options","transaction","what","how","t","this","onsuccess","onerror","objectStore","constructor","name","super","resolve","reject","indexedDB","open","onupgradeneeded","objectStoreNames","length","createObjectStore","oncomplete","event","dispatchEvent","then","boundDispatch","bind","key","startsWith","type","message","isTrusted","Event","close","size","store","count","clear","delete","entries","keys","all","map","get","value","forEach","callback","context","call","has","getKey","getAllKeys","set","put","Symbol","toStringTag","IDBMapSync","Map","queue","args","sync","parse","$parse","stringify","$stringify","JSON","Primitive","String","primitive","ignore","object","noop","_","primitives","Primitives","revive","input","parsed","output","$","lazy","ke","y","k","tmp","add","push","a","i","apply","known","index","replacer","space","firstRun","replace","join","after","from_idb","kind","text","Set","Uint8Array","buffer","storage","async","SyntaxError","v","Proxy","ownKeys","TypeError","to_idb","deleteProperty"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}