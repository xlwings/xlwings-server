{"version":3,"file":"mpy-Dn42TsXA.js","sources":["../src/plugins/py-terminal/mpy.js"],"sourcesContent":["// PyScript pyodide terminal plugin\nimport { defineProperties } from \"polyscript/exports\";\nimport { hooks, inputFailure } from \"../../core.js\";\n\nconst bootstrapped = new WeakSet();\n\n// this callback will be serialized as string and it never needs\n// to be invoked multiple times. Each xworker here is bootstrapped\n// only once thanks to the `sync.is_pyterminal()` check.\nconst workerReady = ({ interpreter, io, run, type }, { sync }) => {\n    if (type !== \"mpy\" || !sync.is_pyterminal()) return;\n\n    const { pyterminal_ready, pyterminal_read, pyterminal_write } = sync;\n\n    interpreter.registerJsModule(\"_pyscript_input\", {\n        input: pyterminal_read,\n    });\n\n    run(\n        [\n            \"from _pyscript_input import input\",\n            \"from polyscript import currentScript as _\",\n            \"__terminal__ = _.terminal\",\n            \"del _\",\n        ].join(\";\"),\n    );\n\n    const missingReturn = new Uint8Array([13]);\n    io.stdout = (buffer) => {\n        if (buffer[0] === 10) pyterminal_write(missingReturn);\n        pyterminal_write(buffer);\n    };\n    io.stderr = (error) => {\n        pyterminal_write(String(error.message || error));\n    };\n\n    sync.pyterminal_stream_write = () => {};\n\n    // tiny shim of the code module with only interact\n    // to bootstrap a REPL like environment\n    interpreter.registerJsModule(\"code\", {\n        interact() {\n            const encoder = new TextEncoderStream();\n            encoder.readable.pipeTo(\n                new WritableStream({\n                    write(buffer) {\n                        for (const c of buffer) interpreter.replProcessChar(c);\n                    },\n                }),\n            );\n\n            const writer = encoder.writable.getWriter();\n            sync.pyterminal_stream_write = (buffer) => writer.write(buffer);\n\n            interpreter.replInit();\n        },\n    });\n\n    pyterminal_ready();\n};\n\nexport default async (element) => {\n    // lazy load these only when a valid terminal is found\n    const [{ Terminal }, { FitAddon }, { WebLinksAddon }] = await Promise.all([\n        import(/* webpackIgnore: true */ \"../../3rd-party/xterm.js\"),\n        import(/* webpackIgnore: true */ \"../../3rd-party/xterm_addon-fit.js\"),\n        import(\n            /* webpackIgnore: true */ \"../../3rd-party/xterm_addon-web-links.js\"\n        ),\n    ]);\n\n    const terminalOptions = {\n        disableStdin: false,\n        cursorBlink: true,\n        cursorStyle: \"block\",\n        lineHeight: 1.2,\n    };\n\n    let stream;\n\n    // common main thread initialization for both worker\n    // or main case, bootstrapping the terminal on its target\n    const init = () => {\n        let target = element;\n        const selector = element.getAttribute(\"target\");\n        if (selector) {\n            target =\n                document.getElementById(selector) ||\n                document.querySelector(selector);\n            if (!target) throw new Error(`Unknown target ${selector}`);\n        } else {\n            target = document.createElement(\"py-terminal\");\n            target.style.display = \"block\";\n            element.after(target);\n        }\n        const terminal = new Terminal({\n            theme: {\n                background: \"#191A19\",\n                foreground: \"#F5F2E7\",\n            },\n            ...terminalOptions,\n        });\n        const fitAddon = new FitAddon();\n        terminal.loadAddon(fitAddon);\n        terminal.loadAddon(new WebLinksAddon());\n        terminal.open(target);\n        fitAddon.fit();\n        terminal.focus();\n        defineProperties(element, {\n            terminal: { value: terminal },\n            process: {\n                value: async (code) => {\n                    for (const line of code.split(/(?:\\r\\n|\\r|\\n)/)) {\n                        await stream.write(`${line}\\r`);\n                    }\n                },\n            },\n        });\n        return terminal;\n    };\n\n    // branch logic for the worker\n    if (element.hasAttribute(\"worker\")) {\n        // add a hook on the main thread to setup all sync helpers\n        // also bootstrapping the XTerm target on main *BUT* ...\n        hooks.main.onWorker.add(function worker(_, xworker) {\n            // ... as multiple workers will add multiple callbacks\n            // be sure no xworker is ever initialized twice!\n            if (bootstrapped.has(xworker)) return;\n            bootstrapped.add(xworker);\n\n            // still cleanup this callback for future scripts/workers\n            hooks.main.onWorker.delete(worker);\n\n            const terminal = init();\n\n            const { sync } = xworker;\n\n            // handle the read mode on input\n            let promisedChunks = null;\n            let readChunks = \"\";\n\n            sync.is_pyterminal = () => true;\n\n            // put the terminal in a read-only state\n            // frees the worker on \\r\n            sync.pyterminal_read = (buffer) => {\n                terminal.write(buffer);\n                promisedChunks = Promise.withResolvers();\n                return promisedChunks.promise;\n            };\n\n            // write if not reading input\n            sync.pyterminal_write = (buffer) => {\n                if (!promisedChunks) terminal.write(buffer);\n            };\n\n            // add the onData terminal listener which forwards to the worker\n            // everything typed in a queued char-by-char way\n            sync.pyterminal_ready = () => {\n                let queue = Promise.resolve();\n                stream = {\n                    write: (buffer) =>\n                        (queue = queue.then(() =>\n                            sync.pyterminal_stream_write(buffer),\n                        )),\n                };\n                terminal.onData((buffer) => {\n                    if (promisedChunks) {\n                        // handle backspace on input\n                        if (buffer === \"\\x7f\") {\n                            // avoid over-greedy backspace\n                            if (readChunks.length) {\n                                readChunks = readChunks.slice(0, -1);\n                                // override previous char position\n                                // put an empty space to clear the char\n                                // move back position again\n                                buffer = \"\\b \\b\";\n                            } else buffer = \"\";\n                        } else readChunks += buffer;\n                        if (buffer) {\n                            terminal.write(buffer);\n                            if (readChunks.endsWith(\"\\r\")) {\n                                terminal.write(\"\\n\");\n                                promisedChunks.resolve(readChunks.slice(0, -1));\n                                promisedChunks = null;\n                                readChunks = \"\";\n                            }\n                        }\n                    } else {\n                        stream.write(buffer);\n                    }\n                });\n            };\n        });\n\n        // setup remote thread JS/Python code for whenever the\n        // worker is ready to become a terminal\n        hooks.worker.onReady.add(workerReady);\n    } else {\n        // ⚠️ In an ideal world the inputFailure should never be used on main.\n        //    However, Pyodide still can't compete with MicroPython REPL mode\n        //    so while it's OK to keep that entry on main as default, we need\n        //    to remove it ASAP from `mpy` use cases, otherwise MicroPython would\n        //    also throw whenever an `input(...)` is required / digited.\n        hooks.main.codeBeforeRun.delete(inputFailure);\n\n        // in the main case, just bootstrap XTerm without\n        // allowing any input as that's not possible / awkward\n        hooks.main.onReady.add(function main({ interpreter, io, run, type }) {\n            if (type !== \"mpy\") return;\n\n            hooks.main.onReady.delete(main);\n\n            const terminal = init();\n\n            const missingReturn = new Uint8Array([13]);\n            io.stdout = (buffer) => {\n                if (buffer[0] === 10) terminal.write(missingReturn);\n                terminal.write(buffer);\n            };\n\n            // expose the __terminal__ one-off reference\n            globalThis.__py_terminal__ = terminal;\n            run(\n                [\n                    \"from js import prompt as input\",\n                    \"from js import __py_terminal__ as __terminal__\",\n                ].join(\";\"),\n            );\n            delete globalThis.__py_terminal__;\n\n            // NOTE: this is NOT the same as the one within\n            //       the onWorkerReady callback!\n            interpreter.registerJsModule(\"code\", {\n                interact() {\n                    const encoder = new TextEncoderStream();\n                    encoder.readable.pipeTo(\n                        new WritableStream({\n                            write(buffer) {\n                                for (const c of buffer)\n                                    interpreter.replProcessChar(c);\n                            },\n                        }),\n                    );\n\n                    stream = encoder.writable.getWriter();\n                    terminal.onData((buffer) => stream.write(buffer));\n\n                    interpreter.replInit();\n                },\n            });\n        });\n    }\n};\n"],"names":["bootstrapped","WeakSet","workerReady","interpreter","io","run","type","sync","is_pyterminal","pyterminal_ready","pyterminal_read","pyterminal_write","registerJsModule","input","join","missingReturn","Uint8Array","stdout","buffer","stderr","error","String","message","pyterminal_stream_write","interact","encoder","TextEncoderStream","readable","pipeTo","WritableStream","write","c","replProcessChar","writer","writable","getWriter","replInit","mpy","async","element","Terminal","FitAddon","WebLinksAddon","Promise","all","import","terminalOptions","disableStdin","cursorBlink","cursorStyle","lineHeight","stream","init","target","selector","getAttribute","document","getElementById","querySelector","Error","createElement","style","display","after","terminal","theme","background","foreground","fitAddon","loadAddon","open","fit","focus","defineProperties","value","process","code","line","split","hasAttribute","hooks","main","onWorker","add","worker","_","xworker","has","delete","promisedChunks","readChunks","withResolvers","promise","queue","resolve","then","onData","length","slice","endsWith","onReady","codeBeforeRun","inputFailure","globalThis","__py_terminal__"],"mappings":"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"}