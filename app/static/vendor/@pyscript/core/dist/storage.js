const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{create:n,getPrototypeOf:r,values:a}=Object,i=r(Int32Array);n(t);const{assign:c}=Object,o="entries",u="readonly",l="readwrite",h={durability:"default",prefix:"IDBMap"},y=({target:{result:e}})=>e;class p extends EventTarget{#e;#t;#s;async#n(e,t){const s=(await this.#e).transaction(o,t,this.#t);return new Promise(((t,n)=>c(e(s.objectStore(o)),{onsuccess:t,onerror:n})))}constructor(e,{durability:t=h.durability,prefix:s=h.prefix}=h){super(),this.#s=s,this.#t={durability:t},this.#e=new Promise(((t,s)=>{c(indexedDB.open(`${this.#s}/${e}`),{onupgradeneeded({target:{result:e,transaction:s}}){e.objectStoreNames.length||e.createObjectStore(o),s.oncomplete=()=>t(e)},onsuccess(e){t(y(e))},onerror(e){s(e),this.dispatchEvent(e)}})})).then((e=>{const t=this.dispatchEvent.bind(this);for(const s in e)s.startsWith("on")&&(e[s]=t);return e}))}dispatchEvent(e){const{type:t,message:s,isTrusted:n}=e;return super.dispatchEvent(n?c(new Event(t),{message:s}):e)}async close(){(await this.#e).close()}get size(){return this.#n((e=>e.count()),u).then(y)}async clear(){await this.#n((e=>e.clear()),l)}async delete(e){await this.#n((t=>t.delete(e)),l)}async entries(){const e=await this.keys();return Promise.all(e.map((e=>this.get(e).then((t=>[e,t])))))}async forEach(e,t=this){for(const[s,n]of await this.entries())await e.call(t,n,s,this)}async get(e){return await this.#n((t=>t.get(e)),u).then(y)}async has(e){return void 0!==await this.#n((t=>t.getKey(e)),u).then(y)}async keys(){return await this.#n((e=>e.getAllKeys()),u).then(y)}async set(e,t){return await this.#n((s=>s.put(t,e)),l),this}async values(){const e=await this.keys();return Promise.all(e.map((e=>this.get(e))))}get[Symbol.toStringTag](){return this.#s}}class f extends Map{#r;#a;constructor(...e){super(),this.#r=new p(...e),this.#a=this.#r.entries().then((e=>{for(const[t,s]of e)super.set(t,s)}))}async close(){await this.#a,await this.#r.close()}async sync(){await this.#a}clear(){return this.#a=this.#a.then((()=>this.#r.clear())),super.clear()}delete(e){return this.#a=this.#a.then((()=>this.#r.delete(e))),super.delete(e)}set(e,t){return this.#a=this.#a.then((()=>this.#r.set(e,t))),super.set(e,t)}}const{parse:w,stringify:d}=JSON,{keys:g}=Object,m=String,b="string",x={},v="object",q=(e,t)=>t,S=e=>e instanceof m?m(e):e,j=(e,t)=>typeof t===b?new m(t):t,E=(e,t,s,n)=>{const r=[];for(let a=g(s),{length:i}=a,c=0;c<i;c++){const i=a[c],o=s[i];if(o instanceof m){const a=e[o];typeof a!==v||t.has(a)?s[i]=n.call(s,i,a):(t.add(a),s[i]=x,r.push({k:i,a:[e,t,a,n]}))}else s[i]!==x&&(s[i]=n.call(s,i,o))}for(let{length:e}=r,t=0;t<e;t++){const{k:e,a:a}=r[t];s[e]=n.call(s,e,E.apply(null,a))}return s},P=(e,t,s)=>{const n=m(t.push(s)-1);return e.set(s,n),n},k=(e,t,s)=>{const n=q,r=new Map,a=[],i=[];let c=+P(r,a,n.call({"":e},"",e)),o=!c;for(;c<a.length;)o=!0,i[c]=d(a[c++],u,s);return"["+i.join(",")+"]";function u(e,t){if(o)return o=!o,t;const s=n.call(this,e,t);switch(typeof s){case v:if(null===s)return s;case b:return r.get(s)||P(r,a,s)}return s}},A=e=>{const[t,s]=(e=>{const t=w(e,j).map(S),s=t[0],n=q,r=typeof s===v&&s?E(t,new Set,s,n):s;return n.call({"":r},"",r)})(e);return"null"===t?null:"generic"===t?s:"bytearray"===t?new Uint8Array(e).buffer:"memoryview"===t?new Uint8Array(e):e},O=async t=>{if(!t)throw new SyntaxError("The storage name must be defined");const s=new f(`@pyscript/${t}`),n=new Map;await s.sync();for(const[e,t]of s.entries())n.set(e,A(t));const r=()=>{n.clear(),s.clear()},a=async()=>{await s.sync()};return new Proxy(n,{ownKeys:e=>[...e.keys()],has:(e,t)=>e.has(t),get:(e,t)=>"clear"===t?r:"sync"===t?a:e.get(t),set:(t,n,r)=>(t.set(n,r),s.set(n,(t=>{if(null==t)return k(["null",0]);switch(typeof t){case"object":if(t instanceof i)return k(["memoryview",[...t]]);if(t instanceof e)return k(["bytearray",[...new Uint8Array(t)]]);case"string":case"number":case"boolean":return k(["generic",t]);default:throw new TypeError(`Unexpected value: ${String(t)}`)}})(r)),!0),deleteProperty:(e,t)=>(e.has(t)&&(e.delete(t),s.delete(t)),!0)})};export{O as storage};
//# sourceMappingURL=storage.js.map
